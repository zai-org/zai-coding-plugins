---
allowed-tools: all
argument-hint: [功能描述]
description: 生成原子级功能列表到 main_feature_list.md
---

# 功能生成

你是一个功能拆分专家。请将用户的需求拆分为原子级功能列表，并生成 `main_feature_list.md` 文件。

## 用户需求

$ARGUMENTS

## 功能要求

1. **分析用户需求**：仔细理解用户的功能描述
2. **拆分为原子级功能（关键！必须细致！）**：

   **原子级功能定义**：一个原子级功能满足以下所有条件：
   - ✅ **单一职责**：只做一件具体的事情
   - ✅ **无法拆分**：不能再进一步拆分成更小的功能
   - ✅ **独立可执行**：不依赖其他功能的完成
   - ✅ **结果明确**：完成后有明确的结果或产出
   - ✅ **时间可控**：单个功能能在合理时间内完成（建议1-2小时内）
   - ✅ **可测试**：可以独立测试和验证

   **判断标准（自检清单）**：
   - ❌ 如果一个功能包含多个步骤 → 需要继续拆分
   - ❌ 如果一个功能需要多个API调用 → 需要继续拆分
   - ❌ 如果一个功能涉及多个组件 → 需要继续拆分
   - ❌ 如果一个功能可以分解为"先做A，再做B" → 需要继续拆分
   - ✅ 如果只是"创建一个文件"、"添加一个方法"、"修改一行代码" → 这是原子级
   - ✅ 如果只是"实现一个API"、"设计一个UI"、"配置一个参数" → 这是原子级

   **必须细致化的场景**：
   1. **API开发**：每个API端点都是一个原子级功能
      - ❌ "实现用户API" → 太大
      - ✅ "创建用户注册API端点" → 原子级
      - ✅ "创建用户登录API端点" → 原子级
      - ✅ "创建用户信息查询API端点" → 原子级

   2. **UI开发**：每个UI组件或页面都是一个原子级功能
      - ❌ "实现用户页面" → 太大
      - ✅ "创建用户注册表单UI" → 原子级
      - ✅ "添加表单验证逻辑" → 原子级
      - ✅ "实现登录页面布局" → 原子级

   3. **数据库操作**：每个数据模型或操作都是一个原子级功能
      - ❌ "设计数据库" → 太大
      - ✅ "创建用户表结构" → 原子级
      - ✅ "添加商品索引" → 原子级
      - ✅ "实现订单表关联" → 原子级

   4. **配置和环境**：每个配置项都是原子级功能
      - ❌ "配置项目环境" → 太大
      - ✅ "配置数据库连接" → 原子级
      - ✅ "添加环境变量文件" → 原子级
      - ✅ "配置CORS跨域" → 原子级

   **拆分原则**：
   - 当不确定时，继续拆分
   - 每个文件包含1-10个原子级功能
   - 如果一个功能超过10个原子级任务，继续拆分到子文件
3. **生成功能列表**：
   - 创建 `.claude/task/main_feature_list.md` 文件
   - 文件格式：`# 用户原始需求：{用户描述}` 后跟功能列表
   - 每个功能格式：`[ ] {功能描述}`
4. **功能数量**：生成5-15个功能
5. **处理边界情况**：
   - 如果功能超过20项，自动拆分到子文件（使用sub_feature_list_001.md等）
   - 保持功能的可读性和可执行性
6. **多级嵌套拆分（核心优化！）**：
   - 支持无限级嵌套：主文件 → 子文件 → 子子文件 → ...
   - 每个层级都要达到原子级（无法再拆分）
   - 使用缩进或编号表示层级关系
   - 子文件可以继续拆分，直到达到原子级
7. **智能并行执行（使用Task工具）**：
   - ✅ 可以使用Task工具并行执行无依赖的功能
   - ✅ 模型自己判断哪些功能可以并行执行
   - ✅ 有依赖的功能顺序执行，无依赖的功能可以并行
   - ✅ 使用Task(subagent_type='general-purpose', ...)创建并行任务

## 功能执行规则（重要！）

在生成功能列表时，必须遵守以下执行规则：

### 1. 多级嵌套功能拆分（核心优化！）

#### 嵌套层级结构
支持无限级嵌套，每个层级都可以继续拆分：

```
Level 0: main_feature_list.md (主文件)
    ├── Level 1: sub_user_management.md (用户管理模块)
    │   ├── Level 2: sub_user_auth.md (用户认证子模块)
    │   │   ├── Level 3: sub_user_register.md (用户注册功能)
    │   │   ├── Level 3: sub_user_login.md (用户登录功能)
    │   │   └── Level 3: sub_user_logout.md (用户登出功能)
    │   ├── Level 2: sub_user_profile.md (用户资料子模块)
    │   │   ├── Level 3: sub_user_info.md (用户信息管理)
    │   │   └── Level 3: sub_user_avatar.md (用户头像管理)
    │   └── Level 2: sub_user_permission.md (用户权限子模块)
    │       ├── Level 3: sub_role_management.md (角色管理)
    │       └── Level 3: sub_permission_config.md (权限配置)
    └── Level 1: sub_product_management.md (商品管理模块)
        ├── Level 2: sub_product_category.md (商品分类子模块)
        ├── Level 2: sub_product_info.md (商品信息子模块)
        └── Level 2: sub_product_search.md (商品搜索子模块)
```

#### 嵌套命名规则
- **主文件**：`main_feature_list.md`
- **第一级子文件**：`sub_{module_name}.md`（如 `sub_user_management.md`）
- **第二级子文件**：`sub_{module_name}_{submodule}.md`（如 `sub_user_auth.md`）
- **第三级子文件**：`sub_{module_name}_{submodule}_{feature}.md`（如 `sub_user_auth_register.md`）
- **继续嵌套**：递归添加后缀

#### 嵌套触发条件
- **Level 0 → Level 1**：主文件功能超过20项或需要按模块分组
- **Level 1 → Level 2**：第一级子文件功能超过20项或需要按子模块分组
- **Level 2 → Level 3**：第二级子文件功能超过20项或需要按功能细分
- **继续嵌套**：任何层级都可以继续拆分，直到达到原子级

#### 嵌套文件结构示例

**主文件 (main_feature_list.md)**：
```markdown
# 用户原始需求：开发完整的电商系统

[ ] sub_user_management.md - 用户管理模块
[ ] sub_product_management.md - 商品管理模块
[ ] sub_order_management.md - 订单管理模块
[ ] sub_payment_system.md - 支付系统模块
```

**第一级子文件 (sub_user_management.md)**：
```markdown
# 用户管理模块

[ ] sub_user_auth.md - 用户认证子模块
[ ] sub_user_profile.md - 用户资料子模块
[ ] sub_user_permission.md - 用户权限子模块
[ ] sub_user_address.md - 用户地址子模块
```

**第二级子文件 (sub_user_auth.md)**：
```markdown
# 用户认证子模块

[ ] sub_user_auth_register.md - 用户注册功能
[ ] sub_user_auth_login.md - 用户登录功能
[ ] sub_user_auth_logout.md - 用户登出功能
[ ] sub_user_auth_reset_password.md - 密码重置功能
[ ] sub_user_auth_change_password.md - 密码修改功能
[ ] sub_user_auth_verify.md - 身份验证功能
[ ] sub_user_auth_oauth.md - 第三方登录功能
[ ] sub_user_auth_token.md - Token管理功能
[ ] sub_user_auth_session.md - 会话管理功能
[ ] sub_user_auth_security.md - 安全设置功能
```

**第三级子文件 (sub_user_auth_register.md)**：
```markdown
# 用户注册功能（原子级）

[ ] 用户注册页面UI设计
[ ] 注册表单验证逻辑
[ ] 用户名重复检查API
[ ] 邮箱格式验证
[ ] 密码强度检查
[ ] 验证码生成和验证
[ ] 用户数据存储到数据库
[ ] 注册成功后的欢迎邮件
[ ] 注册日志记录
[ ] 注册错误处理和提示
```

#### 原子级判断标准
一个功能是否达到原子级，满足以下条件之一：
- ✅ 无法再进一步拆分（单一职责）
- ✅ 可以独立开发和测试（独立功能）
- ✅ 可以独立部署和运行（独立模块）
- ✅ 有明确的输入和输出（清晰的接口）
- ✅ 不依赖其他同级功能（低耦合）

#### 多级嵌套执行流程
```
第1步：读取 main_feature_list.md
       ↓
第2步：找到所有Level 1子文件（sub_*.md）
       ↓
第3步：按顺序执行Level 1子文件
       ├─ 读取 sub_user_management.md
       ├─ 找到所有Level 2子文件（sub_user_*.md）
       ├─ 按顺序执行Level 2子文件
       │   ├─ 读取 sub_user_auth.md
       │   ├─ 找到所有Level 3子文件（sub_user_auth_*.md）
       │   ├─ 按顺序执行Level 3子文件（原子级功能）
       │   └─ 继续递归执行其他Level 2子文件
       ├─ 继续执行其他Level 1子文件
       ↓
第4步：验证所有功能（包括所有层级）已完成
```

### 2. 主功能和子功能的关系（核心！）

#### 为什么需要子功能文件？
- **触发条件**：当功能列表超过20项时自动创建子文件
- **主功能文件作用**：作为总览文件，包含所有功能的引用
- **子功能文件作用**：存放部分详细功能列表，每文件最多20项

#### 主功能文件 vs 子功能文件

| 特性 | 主功能文件 (main_feature_list.md) | 子功能文件 (sub_feature_list_001.md等) |
|------|----------------------------------|----------------------------------------|
| 位置 | `.claude/task/` 目录 | `.claude/task/` 目录 |
| 作用 | 总览和索引 | 详细功能列表 |
| 内容 | 所有功能的总引用 | 部分功能的详细列表 |
| 数量 | 始终1个 | 根据功能数量，0-N个 |
| 执行顺序 | 最先读取和执行 | 按顺序依次执行 |
| 文件格式 | `# 用户原始需求：...` | `# 子功能列表：...` |

#### 创建逻辑
```
功能数量 ≤ 20项 → 只创建 main_feature_list.md
功能数量 > 20项 → 创建 main_feature_list.md + N个子文件
```

#### 执行逻辑
```
第1步：读取 main_feature_list.md
       ↓
第2步：找到所有子功能文件引用
       ↓
第3步：按顺序执行：
       - main_feature_list.md 中的功能
       - sub_feature_list_001.md 中的功能
       - sub_feature_list_002.md 中的功能
       - ...（依次执行所有子文件）
       ↓
第4步：验证所有功能已完成
```

### 2. 主功能和子功能的关联机制（核心！）

#### 关联方式
- **主文件引用子文件**：主文件通过文件名明确引用子文件
  ```markdown
  [ ] sub_feature_list_001.md - 核心功能模块
  [ ] sub_feature_list_002.md - 高级功能模块
  ```
- **子文件包含具体功能**：每个子文件包含一组相关的详细功能
- **状态同步**：主文件中的引用状态与子文件中的功能状态同步

#### 执行逻辑
```
第1步：读取主文件
       ↓
第2步：找到所有引用的子文件
       ↓
第3步：按顺序执行每个子文件中的所有功能
       - sub_feature_list_001.md（20个功能）
       - sub_feature_list_002.md（3个功能）
       - sub_feature_list_003.md（2个功能）
       ↓
第4步：验证所有功能完成
```

#### 主功能文件处理规则
- **主功能文件**：`main_feature_list.md`
- **子功能文件**：`sub_feature_list_001.md`, `sub_feature_list_002.md` 等
- 执行时必须先读取主功能文件，找到所有引用的子功能文件
- 确保所有功能（包括子文件中的功能）都被完整执行
- 状态同步：主文件引用状态与子文件功能状态保持一致

### 3. 功能执行顺序
- **一个功能一个功能执行**：严格按照列表顺序执行
- **不要跳过功能**：即使是简单的功能也要完整执行

### 4. 使用Task工具进行并行执行（推荐）

#### Task工具使用说明
当需要并行执行多个功能时，可以使用Task工具：

**基本语法**：
```python
Task(
    subagent_type='general-purpose',
    description='功能描述',
    prompt='详细的执行指令'
)
```

**并行执行示例**：
```python
# 场景1：无依赖的模块可以并行
# 用户管理和商品管理没有依赖关系，可以并行执行

Task(
    subagent_type='general-purpose',
    description='实现用户管理模块',
    prompt='实现用户管理模块，包括用户注册、登录、密码重置等功能'
)

Task(
    subagent_type='general-purpose',
    description='实现商品管理模块',
    prompt='实现商品管理模块，包括商品分类、列表、详情、搜索等功能'
)
```

**顺序执行示例**：
```python
# 场景2：有依赖的功能必须顺序执行
# 订单管理依赖用户管理和商品管理，必须等待它们完成

# 先完成依赖
Task(..., description='实现用户管理模块')
Task(..., description='实现商品管理模块')

# 再执行依赖功能
Task(..., description='实现订单管理模块')
```

**判断标准**：
- ✅ **无依赖** → 可以并行执行
- ✅ **有依赖** → 必须顺序执行
- ✅ **模型自主判断** → 根据功能描述判断依赖关系

**注意事项**：
- ⚠️ 并行执行会增加资源占用
- ⚠️ 确保并行任务之间没有资源冲突
- ⚠️ 有依赖的功能不要并行执行

### 5. 状态更新责任（重要！必须执行）

在执行功能的过程中，你**必须**主动更新功能列表中的状态：

#### 状态转换规则
```
[ ]  →  [→]  →  [✓]
(未开始) (进行中) (已完成)
```

#### 何时更新状态
- **开始执行一个功能时**：立即将该功能的 `[ ]` 改为 `[→]`
- **完成一个功能时**：立即将该功能的 `[→]` 改为 `[✓]`
- **开始执行一个子模块时**：立即将该子模块的 `[ ]` 改为 `[→]`
- **完成一个子模块的所有功能时**：立即将该子模块的 `[→]` 改为 `[✓]`

#### 如何更新状态
使用 **Edit 工具** 更新 `.claude/task/` 目录下的所有 `.md` 文件：

**示例1：开始执行注册页面UI**
```python
# 读取 sub_user_register_ui.md
# 找到 [ ] 创建注册页面HTML结构文件
# 使用 Edit 改为 [→] 创建注册页面HTML结构文件
```

**示例2：完成注册页面UI的所有任务**
```python
# 读取 sub_user_register_ui.md
# 确认所有任务都是 [✓]
# 读取 sub_user_auth_register.md
# 找到 [→] sub_user_register_ui.md - 注册页面UI
# 使用 Edit 改为 [✓] sub_user_register_ui.md - 注册页面UI
```

**示例3：完成整个用户注册功能**
```python
# 读取 sub_user_auth_register.md
# 确认所有子模块都是 [✓]
# 读取 sub_user_auth.md
# 找到 [→] sub_user_auth_register.md - 用户注册功能
# 使用 Edit 改为 [✓] sub_user_auth_register.md - 用户注册功能
```

#### 状态更新的重要性
- ✅ **记录进度**：让用户清楚知道哪些功能已完成
- ✅ **避免重复**：防止重复执行已完成的任务
- ✅ **保持同步**：确保子文件和父文件状态一致
- ✅ **提供反馈**：Stop hook会根据状态验证完成情况

#### 状态更新的原则
1. **及时更新**：完成一个任务就立即更新，不要等
2. **准确更新**：确保状态变化准确反映实际进度
3. **完整更新**：不仅更新当前任务，还要更新父级状态
4. **验证更新**：更新后再次检查确认状态正确

### 6. 代码实现规则
- **不要省略任何逻辑**：所有原本的逻辑都要完整实现
- **不要使用批量脚本复制类**：
  - 避免使用 `cp`, `copy` 等命令批量复制类文件
  - 每个类文件都要逐个分析和修改
- **不要因篇幅有限就省略方法实现**：
  - 即使方法很长，也要完整实现
  - 不要注释掉方法实现（`// TODO`, `# ...` 等）
  - 不要使用省略标记

### 6. 功能状态管理
每个功能在执行时必须管理三种状态：

**功能状态格式**：
```markdown
[ ] 功能描述                    # Not started（未开始）
[✓] 功能描述                    # Completed（已完成）
[→] 功能描述                    # In progress（进行中）
```

**状态转换规则**：
- 开始执行功能时：`[ ]` → `[→]`
- 完成功能时：`[→]` → `[✓]`
- 不要跳过任何状态转换

### 7. 完整示例：多级嵌套功能拆分

#### 示例场景：开发完整的电商系统（多级嵌套）

这是一个完整的多级嵌套功能拆分示例，展示了如何将一个复杂系统拆分成原子级功能。

**Level 0: 主文件 (main_feature_list.md)**
```markdown
# 用户原始需求：开发完整的电商系统

[ ] sub_user_management.md - 用户管理模块
[ ] sub_product_management.md - 商品管理模块
[ ] sub_order_management.md - 订单管理模块
[ ] sub_payment_system.md - 支付系统模块
[ ] sub_notification_system.md - 通知系统模块
[ ] sub_admin_panel.md - 管理后台模块
[ ] sub_deployment.md - 部署运维模块
```

**Level 1: 用户管理模块 (sub_user_management.md)**
```markdown
# 用户管理模块

[ ] sub_user_auth.md - 用户认证子模块
[ ] sub_user_profile.md - 用户资料子模块
[ ] sub_user_permission.md - 用户权限子模块
[ ] sub_user_address.md - 用户地址子模块
```

**Level 2: 用户认证子模块 (sub_user_auth.md)**
```markdown
# 用户认证子模块

[ ] sub_user_auth_register.md - 用户注册功能
[ ] sub_user_auth_login.md - 用户登录功能
[ ] sub_user_auth_logout.md - 用户登出功能
[ ] sub_user_auth_reset_password.md - 密码重置功能
[ ] sub_user_auth_change_password.md - 密码修改功能
[ ] sub_user_auth_verify.md - 身份验证功能
[ ] sub_user_auth_oauth.md - 第三方登录功能
[ ] sub_user_auth_token.md - Token管理功能
[ ] sub_user_auth_session.md - 会话管理功能
```

**Level 3: 用户注册功能 (sub_user_auth_register.md) - 继续拆分！**

注意：即使是Level 3，如果功能仍然太大，需要继续拆分到Level 4！

❌ **错误的原子级示例**（这些仍然太大）：
```markdown
[ ] 用户注册页面UI设计        # 太大！包含多个步骤
[ ] 注册表单验证逻辑          # 太大！包含多种验证
[ ] 用户数据存储到数据库      # 太大！包含多个操作
```

✅ **正确的原子级示例**（每个都是单一职责）：

**Level 3: 用户注册功能 (sub_user_auth_register.md)**
```markdown
# 用户注册功能（需要继续拆分到Level 4）

[ ] sub_user_register_ui.md - 注册页面UI
[ ] sub_user_register_validation.md - 注册验证逻辑
[ ] sub_user_register_api.md - 注册API接口
[ ] sub_user_register_email.md - 注册邮件发送
```

**Level 4: 注册页面UI (sub_user_register_ui.md) - 真正的原子级**
```markdown
# 注册页面UI（原子级）

[ ] 创建注册页面HTML结构文件
[ ] 设计注册页面CSS样式
[ ] 添加注册页面响应式布局
[ ] 实现注册页面输入框样式
[ ] 添加注册按钮样式和效果
[ ] 实现注册页面加载动画
[ ] 添加注册页面表单提示文本
[ ] 实现注册页面错误提示UI
[ ] 添加注册页面成功提示UI
[ ] 优化注册页面移动端显示
```

**Level 4: 注册验证逻辑 (sub_user_register_validation.md) - 真正的原子级**
```markdown
# 注册验证逻辑（原子级）

[ ] 实现用户名非空验证
[ ] 实现用户名长度验证（3-20字符）
[ ] 实现用户名格式验证（字母数字下划线）
[ ] 实现邮箱格式验证
[ ] 实现密码强度验证（至少8位）
[ ] 实现密码一致性验证（两次输入一致）
[ ] 实现验证码非空验证
[ ] 实现前端验证错误提示显示
[ ] 添加验证表单提交拦截逻辑
```

**Level 4: 注册API接口 (sub_user_register_api.md) - 真正的原子级**
```markdown
# 注册API接口（原子级）

[ ] 创建注册API路由
[ ] 实现用户名重复检查接口
[ ] 实现邮箱重复检查接口
[ ] 实现用户密码加密存储
[ ] 实现用户信息保存到数据库
[ ] 实现注册成功返回Token
[ ] 实现注册失败错误返回
[ ] 添加注册API日志记录
[ ] 实现注册API限流保护
[ ] 添加注册API参数验证
```

**Level 4: 注册邮件发送 (sub_user_register_email.md) - 真正的原子级**
```markdown
# 注册邮件发送（原子级）

[ ] 配置邮件服务SMTP
[ ] 设计注册成功邮件模板
[ ] 实现邮件发送功能
[ ] 添加邮件发送重试机制
[ ] 实现邮件发送失败日志
[ ] 添加邮件发送状态追踪
[ ] 优化邮件内容HTML格式
[ ] 实现邮件批量发送队列
```

**Level 3: 用户登录功能 (sub_user_auth_login.md) - 继续拆分！**
```markdown
# 用户登录功能（需要继续拆分到Level 4）

[ ] sub_user_login_ui.md - 登录页面UI
[ ] sub_user_login_validation.md - 登录验证逻辑
[ ] sub_user_login_api.md - 登录API接口
[ ] sub_user_login_token.md - Token管理
[ ] sub_user_login_session.md - 会话管理
```

**Level 4: 登录页面UI (sub_user_login_ui.md) - 真正的原子级**
```markdown
# 登录页面UI（原子级）

[ ] 创建登录页面HTML结构文件
[ ] 设计登录页面CSS样式
[ ] 添加登录页面响应式布局
[ ] 实现登录表单输入框样式
[ ] 添加登录按钮样式和效果
[ ] 实现记住登录状态UI
[ ] 添加第三方登录按钮样式
[ ] 实现登录页面加载状态
[ ] 添加登录错误提示UI
[ ] 优化登录页面移动端显示
```

**Level 4: 登录验证逻辑 (sub_user_login_validation.md) - 真正的原子级**
```markdown
# 登录验证逻辑（原子级）

[ ] 实现用户名非空验证
[ ] 实现密码非空验证
[ ] 添加输入格式验证
[ ] 实现前端验证错误提示
[ ] 添加验证表单提交拦截
[ ] 实现登录失败计数功能
[ ] 添加账户锁定提示逻辑
```

**Level 4: 登录API接口 (sub_user_login_api.md) - 真正的原子级**
```markdown
# 登录API接口（原子级）

[ ] 创建登录API路由
[ ] 实现用户名密码验证
[ ] 实现登录失败次数限制
[ ] 实现Token生成和返回
[ ] 实现登录成功返回用户信息
[ ] 实现登录失败错误返回
[ ] 添加登录API日志记录
[ ] 实现登录API限流保护
[ ] 添加登录IP地址记录
```

**Level 4: Token管理 (sub_user_login_token.md) - 真正的原子级**
```markdown
# Token管理（原子级）

[ ] 实现JWT Token生成函数
[ ] 实现Token验证中间件
[ ] 实现Token刷新机制
[ ] 实现Token黑名单功能
[ ] 添加Token过期处理
[ ] 实现Token自动续期
```

**Level 4: 会话管理 (sub_user_login_session.md) - 真正的原子级**
```markdown
# 会话管理（原子级）

[ ] 创建用户会话存储表
[ ] 实现会话创建功能
[ ] 实现会话查询功能
[ ] 实现会话更新功能
[ ] 实现会话销毁功能
[ ] 添加会话过期清理
[ ] 实现多设备登录管理
```

#### 执行流程详解

**第1步**：读取 `main_feature_list.md`
- 发现7个模块，按顺序执行

**第2步**：执行用户管理模块
- 读取 `sub_user_management.md`
- 发现4个子模块
- 按顺序执行子模块

**第3步**：执行用户认证子模块
- 读取 `sub_user_auth.md`
- 发现3个功能（注册、登录、登出）
- 按顺序执行功能

**第4步**：执行用户注册功能（原子级）
- 读取 `sub_user_auth_register.md`
- 发现10个原子级任务
- 按顺序执行所有原子级任务
- 完成后标记为 `[✓]`

**第5步**：继续执行其他功能
- 用户登录功能（原子级）
- 用户登出功能（原子级）
- ...

#### 关键优势

1. **无限级嵌套**：可以继续拆分直到达到原子级
2. **清晰的层级**：每个层级都有明确的职责
3. **原子级保证**：最底层都是无法再拆分的原子级功能
4. **灵活扩展**：可以根据需要增加嵌套层级
5. **易于管理**：每个文件只包含相关的功能

#### 如何判断是否需要继续拆分（关键指导！）

**拆分自检清单**：当你生成一个功能时，问自己以下问题：

❌ **必须拆分的信号**：
- 这个功能需要3个或更多步骤来完成？
- 这个功能涉及多个文件或多个组件？
- 这个功能可以分解为"先做A，再做B，再做C"？
- 这个功能需要调用多个API或数据库操作？
- 预估完成时间超过1-2小时？
- 这个功能包含多个不同的职责？

✅ **可以不拆分的信号**：
- 这个功能只是一个单一的文件创建？
- 这个功能只是一个方法或函数的实现？
- 这个功能只是一个简单的配置或修改？
- 这个功能可以立即测试和验证？
- 预估完成时间在1-2小时以内？
- 这个功能只有一个明确的职责？

**实际案例分析**：

**案例1：用户注册功能**
```
❌ 错误的原子级：
[ ] 用户注册功能

✅ 正确的拆分：
[ ] sub_user_register_ui.md - 注册页面UI
[ ] sub_user_register_validation.md - 注册验证逻辑
[ ] sub_user_register_api.md - 注册API接口
[ ] sub_user_register_email.md - 注册邮件发送

继续检查Level 4：
❌ sub_user_register_ui.md 仍然太大：
[ ] 设计注册页面

✅ 拆分到Level 4：
[ ] 创建注册页面HTML结构文件
[ ] 设计注册页面CSS样式
[ ] 添加注册页面响应式布局
[ ] 实现注册页面输入框样式
[ ] 添加注册按钮样式和效果
[ ] 实现注册页面加载动画
[ ] 添加注册页面表单提示文本
[ ] 实现注册页面错误提示UI
[ ] 添加注册页面成功提示UI
[ ] 优化注册页面移动端显示
```

**案例2：数据库设计**
```
❌ 错误的原子级：
[ ] 设计用户数据库

✅ 正确的拆分：
[ ] 创建用户表结构
[ ] 添加用户索引
[ ] 创建用户角色关联表
[ ] 实现数据库迁移脚本
[ ] 配置数据库连接

继续检查每个任务：
❌ 创建用户表结构 仍然太大：
[ ] 创建用户表

✅ 拆分到Level 4：
[ ] 创建用户表SQL文件
[ ] 定义用户表字段结构
[ ] 添加用户表主键
[ ] 创建用户表唯一索引
[ ] 添加用户表时间戳字段
[ ] 编写用户表创建脚本
[ ] 测试用户表创建
```

**案例3：API开发**
```
❌ 错误的原子级：
[ ] 实现用户管理API

✅ 正确的拆分：
[ ] 创建用户列表API
[ ] 创建用户详情API
[ ] 创建用户创建API
[ ] 创建用户更新API
[ ] 创建用户删除API

继续检查每个API：
❌ 创建用户创建API 仍然太大：
[ ] 实现用户创建接口

✅ 拆分到Level 4：
[ ] 创建用户创建路由
[ ] 实现请求参数验证
[ ] 实现用户名重复检查
[ ] 实现密码加密处理
[ ] 实现用户数据保存
[ ] 实现创建成功响应
[ ] 实现创建失败响应
[ ] 添加API日志记录
[ ] 实现API限流保护
```

**拆分决策树**：

```
是否需要拆分？
│
├─ 是 → 这个功能可以分解为多个步骤？
│   │
│   ├─ 是 → 继续拆分
│   │   │
│   │   └─ 重复直到答案为"否"
│   │
│   └─ 否 → 是否涉及多个文件或组件？
│       │
│       ├─ 是 → 继续拆分
│       │
│       └─ 否 → 是否预估超过1-2小时？
│           │
│           ├─ 是 → 继续拆分
│           │
│           └─ 否 → ✅ 这是原子级！
│
└─ 否 → ✅ 这是原子级！
```

**细致化原则总结**：

1. **当不确定时，继续拆分** - 拆分过度比拆分不足更好
2. **每个任务都要能独立完成** - 不依赖其他任务的中间状态
3. **每个任务都要能独立测试** - 可以立即验证结果
4. **每个任务都要有明确产出** - 完成后有可见的结果
5. **每个任务时间要可控** - 建议1-2小时内完成

##### main_feature_list.md (主功能文件 - 模块化设计)
```markdown
# 用户原始需求：开发完整的电商系统

[ ] sub_user_management.md - 用户管理模块
[ ] sub_product_management.md - 商品管理模块
[ ] sub_order_management.md - 订单管理模块
[ ] sub_payment_system.md - 支付系统模块
[ ] sub_notification_system.md - 通知系统模块
[ ] sub_admin_panel.md - 管理后台模块
[ ] sub_deployment.md - 部署运维模块
```

**模块化设计原则**：
- ✅ **按业务功能模块分组** - 每个模块对应一个完整的业务功能
- ✅ **模块独立性** - 每个模块可以独立开发和测试
- ✅ **模块完整性** - 每个模块包含所有必需的功能
- ✅ **清晰边界** - 模块之间职责明确，避免重叠

**为什么这样设计？**
- ✅ 业务导向 - 按照实际业务场景组织功能
- ✅ 易于理解 - 开发者清楚每个模块的职责
- ✅ 易于维护 - 修改某个模块不影响其他模块
- ✅ 易于测试 - 可以对每个模块进行独立测试

##### 自动拆分后的文件结构

当功能数量 > 20时，系统会自动创建：

```
.claude/task/
├── main_feature_list.md          # 主文件（总览）
├── sub_feature_list_001.md       # 子文件1（功能1-20）
└── sub_feature_list_002.md       # 子文件2（功能21-25）
```

##### sub_user_management.md (用户管理模块 - 4个功能)
```markdown
# 子功能列表：用户管理模块
## 来源：开发完整的电商系统

[ ] 用户注册功能
[→] 用户登录功能
[ ] 密码重置功能
[ ] 用户地址管理
```

**模块职责**：负责所有用户相关的功能，包括注册、登录、密码管理和地址管理

##### sub_product_management.md (商品管理模块 - 5个功能)
```markdown
# 子功能列表：商品管理模块
## 来源：开发完整的电商系统

[ ] 商品分类管理
[ ] 商品列表展示
[ ] 商品详情页
[ ] 商品搜索功能
[ ] 商品筛选功能
```

**模块职责**：负责商品展示、搜索和筛选功能

##### sub_order_management.md (订单管理模块 - 4个功能)
```markdown
# 子功能列表：订单管理模块
## 来源：开发完整的电商系统

[ ] 购物车管理
[ ] 购物车增删改
[ ] 订单创建
[ ] 订单状态跟踪
```

**模块职责**：负责购物车和订单的完整流程管理

##### sub_payment_system.md (支付系统模块 - 3个功能)
```markdown
# 子功能列表：支付系统模块
## 来源：开发完整的电商系统

[ ] 订单支付
[ ] 支付回调处理
[ ] 支付状态同步
```

**模块职责**：负责支付相关的所有功能

##### sub_notification_system.md (通知系统模块 - 3个功能)
```markdown
# 子功能列表：通知系统模块
## 来源：开发完整的电商系统

[ ] 邮件通知
[ ] 短信通知
[ ] 站内消息
```

**模块职责**：负责各类通知功能

##### sub_admin_panel.md (管理后台模块 - 3个功能)
```markdown
# 子功能列表：管理后台模块
## 来源：开发完整的电商系统

[ ] 管理员登录
[ ] 数据统计分析
[ ] 用户管理
```

**模块职责**：负责管理后台的所有功能

##### sub_deployment.md (部署运维模块 - 3个功能)
```markdown
# 子功能列表：部署运维模块
## 来源：开发完整的电商系统

[ ] 性能优化
[ ] 部署上线
[ ] 监控和日志配置
```

**模块职责**：负责部署和运维相关功能

#### 执行流程详解（按模块执行）

**重要：必须按模块完整执行，不要跨模块！**

**第1步**：读取 `main_feature_list.md`
- 系统读取主功能文件
- 发现引用了7个业务模块：
  1. `sub_user_management.md - 用户管理模块`
  2. `sub_product_management.md - 商品管理模块`
  3. `sub_order_management.md - 订单管理模块`
  4. `sub_payment_system.md - 支付系统模块`
  5. `sub_notification_system.md - 通知系统模块`
  6. `sub_admin_panel.md - 管理后台模块`
  7. `sub_deployment.md - 部署运维模块`

**第2步**：按模块顺序执行（关键！）

**模块1：用户管理模块**
- **目标**：完成所有用户相关功能
- **功能数**：4个
- **执行**：
  - 用户注册功能 `[ ]` → `[→]` → `[✓]`
  - 用户登录功能 `[ ]` → `[→]` → `[✓]`
  - 密码重置功能 `[ ]` → `[→]` → `[✓]`
  - 用户地址管理 `[ ]` → `[→]` → `[✓]`
- **模块状态**：完成主文件中 `[ ] sub_user_management.md` → `[✓] sub_user_management.md`

**模块2：商品管理模块**
- **目标**：完成所有商品展示和搜索功能
- **功能数**：5个
- **执行**：
  - 商品分类管理 `[ ]` → `[→]` → `[✓]`
  - 商品列表展示 `[ ]` → `[→]` → `[✓]`
  - 商品详情页 `[ ]` → `[→]` → `[✓]`
  - 商品搜索功能 `[ ]` → `[→]` → `[✓]`
  - 商品筛选功能 `[ ]` → `[→]` → `[✓]`
- **模块状态**：完成主文件中 `[ ] sub_product_management.md` → `[✓] sub_product_management.md`

**模块3：订单管理模块**
- **目标**：完成购物车和订单流程
- **功能数**：4个
- **执行**：
  - 购物车管理 `[ ]` → `[→]` → `[✓]`
  - 购物车增删改 `[ ]` → `[→]` → `[✓]`
  - 订单创建 `[ ]` → `[→]` → `[✓]`
  - 订单状态跟踪 `[ ]` → `[→]` → `[✓]`
- **模块状态**：完成主文件中 `[ ] sub_order_management.md` → `[✓] sub_order_management.md`

**模块4：支付系统模块**
- **目标**：完成支付相关功能
- **功能数**：3个
- **执行**：
  - 订单支付 `[ ]` → `[→]` → `[✓]`
  - 支付回调处理 `[ ]` → `[→]` → `[✓]`
  - 支付状态同步 `[ ]` → `[→]` → `[✓]`
- **模块状态**：完成主文件中 `[ ] sub_payment_system.md` → `[✓] sub_payment_system.md`

**模块5：通知系统模块**
- **目标**：完成所有通知功能
- **功能数**：3个
- **执行**：
  - 邮件通知 `[ ]` → `[→]` → `[✓]`
  - 短信通知 `[ ]` → `[→]` → `[✓]`
  - 站内消息 `[ ]` → `[→]` → `[✓]`
- **模块状态**：完成主文件中 `[ ] sub_notification_system.md` → `[✓] sub_notification_system.md`

**模块6：管理后台模块**
- **目标**：完成管理后台功能
- **功能数**：3个
- **执行**：
  - 管理员登录 `[ ]` → `[→]` → `[✓]`
  - 数据统计分析 `[ ]` → `[→]` → `[✓]`
  - 用户管理 `[ ]` → `[→]` → `[✓]`
- **模块状态**：完成主文件中 `[ ] sub_admin_panel.md` → `[✓] sub_admin_panel.md`

**模块7：部署运维模块**
- **目标**：完成部署和运维
- **功能数**：3个
- **执行**：
  - 性能优化 `[ ]` → `[→]` → `[✓]`
  - 部署上线 `[ ]` → `[→]` → `[✓]`
  - 监控和日志配置 `[ ]` → `[→]` → `[✓]`
- **模块状态**：完成主文件中 `[ ] sub_deployment.md` → `[✓] sub_deployment.md`

**第3步**：验证所有模块
- 系统统计：
  - 模块总数：7个
  - 已完成模块：7个
  - 每个模块的功能数：
    - 用户管理：4个
    - 商品管理：5个
    - 订单管理：4个
    - 支付系统：3个
    - 通知系统：3个
    - 管理后台：3个
    - 部署运维：3个
  - 总功能数：25个
  - 已完成功能：25个
  - 未完成功能：0个

**关键提醒**：
- ✅ 必须按模块完整执行，不要跳过模块
- ✅ 一个模块完成后才能开始下一个模块
- ✅ 模块内部的功能也要按顺序执行
- ✅ 状态同步：子文件功能状态 ↔ 主文件模块状态

#### 关键点说明（模块化执行）

1. **模块化分组（核心！）**：
   - ✅ 按业务功能模块分组，不是简单的编号分组
   - ✅ 每个模块对应一个完整的业务功能
   - ✅ 模块之间职责明确，避免功能重叠
   - ✅ 示例：用户管理模块、商品管理模块、订单管理模块

2. **模块完整性**：
   - ✅ 每个模块包含所有必需的功能
   - ✅ 模块内部功能按顺序执行
   - ✅ 一个模块完成后才能开始下一个模块
   - ✅ 不允许跨模块执行（比如商品模块未完成不能做支付模块）

3. **模块独立性**：
   - ✅ 每个模块可以独立开发和测试
   - ✅ 修改某个模块不影响其他模块
   - ✅ 易于理解每个模块的职责和边界
   - ✅ 便于团队分工协作

4. **状态同步机制**：
   - 子文件中：功能状态 `[ ]` → `[→]` → `[✓]`
   - 主文件中：模块状态同步更新
   - 模块开始执行：主文件中 `[ ] sub_user_management.md` → `[→] sub_user_management.md`
   - 模块全部完成：主文件中 `[→] sub_user_management.md` → `[✓] sub_user_management.md`

5. **执行顺序**：
   - 必须严格按照主文件中的模块顺序执行
   - 用户管理 → 商品管理 → 订单管理 → 支付系统 → 通知系统 → 管理后台 → 部署运维
   - 每个模块的功能也要按顺序执行

### 7. 简单示例（功能 ≤ 20项）

如果功能不超过20项，只创建主文件，直接列出功能：

```markdown
# 用户原始需求：重构用户认证系统

[ ] 分析现有认证系统的代码结构
[→] 识别可以改进的设计模式
[ ] 设计新的认证架构
[ ] 实现JWT token管理
[ ] 添加OAuth 2.0支持
[ ] 实现密码加密和盐值处理
[ ] 添加双因素认证（2FA）
[ ] 实现会话管理
[ ] 编写单元测试
[ ] 集成测试
[ ] 更新API文档
[ ] 迁移现有用户数据
[ ] 性能测试和优化
[ ] 部署到生产环境
[ ] 监控和日志配置
```

**注意**：这个例子只有15个功能，没有超过20项限制，因此：
- ✅ 只创建 `main_feature_list.md`
- ✅ 主文件直接列出所有功能
- ✅ 没有子文件
- ✅ 执行时直接按顺序执行主文件中的功能

## 输出格式

```markdown
# 用户原始需求：{用户的原始描述}

[ ] 功能1
[ ] 功能2
[ ] 功能3
...
```

## 注意事项

- 不要使用markdown编号，只使用 `[ ]`
- 保持功能描述简洁清晰
- 确保功能之间有逻辑顺序
- 如果无法生成功能列表，使用fallback模板（根据需求类型选择重构/开发/测试/优化等模板）

## Fallback模板

如果无法生成合适的功能列表，使用以下模板之一：

**重构类功能**：
```
[ ] 读取并分析现有代码结构
[ ] 理解业务需求和逻辑
[ ] 设计新的架构方案
[ ] 实现核心功能模块
[ ] 迁移和重构代码
[ ] 处理依赖和配置
[ ] 测试验证功能
[ ] 编写文档
```

**开发类功能**：
```
[ ] 分析需求和功能点
[ ] 设计系统架构
[ ] 创建项目结构
[ ] 实现核心功能
[ ] 实现用户界面
[ ] 添加测试用例
[ ] 配置和部署
[ ] 编写使用文档
```

**测试类功能**：
```
[ ] 理解测试范围
[ ] 分析现有代码
[ ] 设计测试方案
[ ] 编写测试用例
[ ] 执行测试
[ ] 验证功能完整性
[ ] 记录测试结果
[ ] 生成测试报告
```

**优化类功能**：
```
[ ] 性能分析
[ ] 识别瓶颈
[ ] 优化代码
[ ] 验证改进
[ ] 文档更新
```

现在请根据用户的需求生成功能列表并创建文件。
